use std::collections::HashMap;
use rust_stemmers::{Algorithm, Stemmer};
use super::Lang;
use crate::lexis::PartOfSpeech;


const ARTICLES: [&'static str; 0] = [

];

const PREPOSITIONS: [&'static str; 61] = [
    "c",
    "без",
    "благодаря",
    "в",
    "ввиду",
    "вдоль",
    "вместо",
    "вне",
    "внутри",
    "внутрь",
    "во",
    "возле",
    "вокруг",
    "вопреки",
    "впереди",
    "вследствие",
    "для",
    "до",
    "за",
    "из-за",
    "из-под",
    "из",
    "к",
    "ко",
    "кроме",
    "между",
    "мимо",
    "на",
    "над",
    "надо",
    "напротив",
    "насчет",
    "о",
    "об",
    "около",
    "от",
    "ото",
    "перед",
    "передо",
    "по",
    "под",
    "подле",
    "подо",
    "позади",
    "помимо",
    "после",
    "посреди",
    "посредством",
    "при",
    "про",
    "против",
    "путём",
    "ради",
    "с",
    "сверх",
    "свыше",
    "сквозь",
    "со",
    "среди",
    "у",
    "через",
];

const CONJUNCTIONS: [&'static str; 51] = [
    "а",
    "а",
    "будто",
    "впрочем",
    "где",
    "да",
    "едва",
    "ежели",
    "если",
    "же",
    "зато",
    "и",
    "ибо",
    "или",
    "именно",
    "как",
    "как",
    "когда",
    "которая",
    "которого",
    "которое",
    "котором",
    "которую",
    "которые",
    "который",
    "которых",
    "ли",
    "либо",
    "лишь",
    "настолько",
    "но",
    "однако",
    "пока",
    "покамест",
    "покуда",
    "пускай",
    "пусть",
    "раз",
    "словно",
    "также",
    "то",
    "тоже",
    "точно",
    "хоть",
    "хотя",
    "чем",
    "что",
    "что",
    "чтобы",
    "чтобы",
    "чуть",
    // "а именно",
    // "а то",
    // "благодаря тому что",
    // "будто бы",
    // "в то время как",
    // "ввиду того что",
    // "всё же",
    // "да нет",
    // "для того чтобы",
    // "до того как",
    // "до того",
    // "ещё не ... как",
    // "и ... и",
    // "или ... или",
    // "как ... ни",
    // "как будто бы",
    // "как будто",
    // "как бы",
    // "как ни",
    // "как только",
    // "либо ... либо",
    // "между тем как",
    // "настолько ... насколько",
    // "не ... как",
    // "не настолько ... насколько",
    // "не так ... как",
    // "не то ... не то",
    // "не то что",
    // "не то чтобы",
    // "не только ... но и",
    // "несмотря на то что",
    // "ни ... ни",
    // "оттого что",
    // "перед тем как",
    // "пока .. не",
    // "пока не",
    // "после того как",
    // "потому что",
    // "правда ... но",
    // "прежде чем",
    // "разве только",
    // "разве что",
    // "с тех пор как",
    // "так как",
    // "так что",
    // "то ... то",
    // "то есть",
    // "чем ... тем",
    // "чтобы не",
];

const PARTICLES: [&'static str; 32] = [
    "будто",
    "бы",
    "ведь",
    "ведь",
    "вон",
    "вот",
    "да",
    "даже",
    "есть",
    "же",
    "здесь",
    "именно",
    "лишь",
    "не",
    "нет",
    "неужели",
    "ни",
    "ну",
    "ну",
    "пожалуй",
    "почти",
    "просто",
    "разве",
    "словно",
    "там",
    "только",
    "угодно",
    "уж",
    "хоть",
    "хотя",
    "чуть",
    "это",
    // "вряд ли",
    // "да ну",
    // "даже и",
    // "едва ли",
    // "ещё бы",
    // "как будто",
    // "как раз",
    // "лишь только",
    // "ни ... ни",
    // "ну да",
    // "ну и",
    // "только лишь",
    // "хоть бы",
    // "хотя бы",
    // "чуть ли не",
    // "чуть ли",
    // "чуть не",
];


pub fn lang_russian() -> Lang {
    let stemmer = Stemmer::create(Algorithm::Russian);

    let mut pos_map = HashMap::new();
    for w in &ARTICLES[..]     { pos_map.insert(w.chars().collect(), PartOfSpeech::Article); }
    for w in &PREPOSITIONS[..] { pos_map.insert(w.chars().collect(), PartOfSpeech::Preposition); }
    for w in &CONJUNCTIONS[..] { pos_map.insert(w.chars().collect(), PartOfSpeech::Conjunction); }
    for w in &PARTICLES[..]    { pos_map.insert(w.chars().collect(), PartOfSpeech::Particle); }

    Lang::new(pos_map, stemmer)
}


#[cfg(test)]
mod tests {
    use crate::lexis::PartOfSpeech;
    use super::lang_russian;

    #[test]
    pub fn stem() {
        let lang = lang_russian();
        let w1 = "важный".chars().collect::<Vec<_>>();
        let w2 = "ведь"  .chars().collect::<Vec<_>>();
        assert_eq!(lang.stem(&w1), 4);
        assert_eq!(lang.stem(&w2), 3);
    }

    #[test]
    pub fn get_pos() {
        let lang = lang_russian();
        let w1 = "важный".chars().collect::<Vec<_>>();
        let w2 = "ведь"  .chars().collect::<Vec<_>>();
        assert_eq!(lang.get_pos(&w1), None);
        assert_eq!(lang.get_pos(&w2), Some(PartOfSpeech::Particle));
    }
}